the grammar for the above program is 
1. S → statement
2. statement → if (A)| (statement)(statement) | y
3. y ∈ statement alphabets [Σstatement]
4. A → (cond)(statement) | (cond)(statement)(else)(statement)
5. cond → (x)(op1)(x) | x
6. op1 → + | - | * | / |ˆ| < | > | =
7. x → R | cond | y
NOTE: Σstatement = numbers ∪ keywords ∪ identifiers - ’if ’ and ’else’. It does NOT include operations.
Execution:
1. The above grammar is in CFG.First we should convert it to CNF.
2. After converting to CNF the rules:
   "S": ["BA","SS",notifelse()],
    "B":["if"],
    "K":["SV"],
    "V":["LS"],
    "A":["CS","CK"],
    "L":["else"],
    "C":["RM","CM","YM",isintegervar(),notifelse()],
    "M":["OR","OC","OY"],
    "O":["+","-","*","/","^","<",">","="],
    "R":[isintegervar()],
    "Y":[notifelse()]
3. CYK (Cocke-Younger-Kasami) algorithm is used to decide whether the string is present in the Grammar.
4. We use bottom to top approach for finding this by splitting each terminal and noting the corresponding production variable and then combining till end to find whether the string can be generated by Grammar.
Assumptions:
1. Space is not considered as symbol and no significance as statement after if and else
2. negative numbers are not present at the start of the string
3. Although Syntax error is shown correct, accurately the position of the error cannot be calculated.It only gives the string where the high probability of error may be found according to the grammar.

Assumptions for generator:
1. There may be variation of output as Random is used and may not be accurate.